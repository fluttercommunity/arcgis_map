"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[4747],{33987:(e,t,i)=>{i.d(t,{Z:()=>T});var n=i(43405),a=i(6286),r=i(73353);const o=e=>(0,r.K)({ID:e.id,PATTERN:e.pattern}),l={shaders:e=>({vertexShader:o(e)+(0,a.w)("background/background.vert"),fragmentShader:o(e)+(0,a.w)("background/background.frag")})},s=e=>(0,r.K)({ID:e.id}),d={shaders:e=>({vertexShader:s(e)+(0,a.w)("circle/circle.vert"),fragmentShader:s(e)+(0,a.w)("circle/circle.frag")})},c=e=>(0,r.K)({ID:e.id,PATTERN:e.pattern}),u={shaders:e=>({vertexShader:c(e)+(0,a.w)("fill/fill.vert"),fragmentShader:c(e)+(0,a.w)("fill/fill.frag")})},f=e=>(0,r.K)({ID:e.id}),_={shaders:e=>({vertexShader:f(e)+(0,a.w)("outline/outline.vert"),fragmentShader:f(e)+(0,a.w)("outline/outline.frag")})},m=e=>(0,r.K)({ID:e.id,SDF:e.sdf}),p={shaders:e=>({vertexShader:m(e)+(0,a.w)("icon/icon.vert"),fragmentShader:m(e)+(0,a.w)("icon/icon.frag")})},v=e=>(0,r.K)({ID:e.id,PATTERN:e.pattern,SDF:e.sdf}),g={shaders:e=>({vertexShader:v(e)+(0,a.w)("line/line.vert"),fragmentShader:v(e)+(0,a.w)("line/line.frag")})},h=e=>(0,r.K)({ID:e.id}),y={shaders:e=>({vertexShader:h(e)+(0,a.w)("text/text.vert"),fragmentShader:h(e)+(0,a.w)("text/text.frag")})};class T{constructor(){this._programByKey=new Map}dispose(){this._programByKey.forEach((e=>e.dispose())),this._programByKey.clear()}getMaterialProgram(e,t,i){const n=t.key<<3|this._getMaterialOptionsValue(t.type,i);if(this._programByKey.has(n))return this._programByKey.get(n);const a=this._getProgramTemplate(t.type),{shaders:r}=a,{vertexShader:o,fragmentShader:l}=r(i),s=t.getShaderHeader(),d=t.getShaderMain(),c=o.replace("#pragma header",s).replace("#pragma main",d),u=e.programCache.acquire(c,l,t.getAttributeLocations());return this._programByKey.set(n,u),u}_getMaterialOptionsValue(e,t){switch(e){case n._K.BACKGROUND:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case n._K.FILL:{const e=t;return(e.pattern?1:0)<<1|(e.id?1:0)}case n._K.OUTLINE:return t.id?1:0;case n._K.LINE:{const e=t;return(e.sdf?1:0)<<2|(e.pattern?1:0)<<1|(e.id?1:0)}case n._K.ICON:{const e=t;return(e.sdf?1:0)<<1|(e.id?1:0)}case n._K.CIRCLE:case n._K.TEXT:return t.id?1:0;default:return 0}}_getProgramTemplate(e){switch(e){case n._K.BACKGROUND:return l;case n._K.CIRCLE:return d;case n._K.FILL:return u;case n._K.ICON:return p;case n._K.LINE:return g;case n._K.OUTLINE:return _;case n._K.TEXT:return y;default:return null}}}},6286:(e,t,i)=>{i.d(t,{w:()=>r});const n={background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main() {\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = u_opacity * color;\n#else\ngl_FragColor = u_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","background.vert":"precision mediump float;\nattribute vec2 a_pos;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\nuniform mediump vec4 u_tlbr;\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\n#endif\nvoid main() {\ngl_Position = vec4((u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0)).xy, u_depth, 1.0);\n#ifdef PATTERN\nv_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\nv_tlbr             = u_tlbr / u_mosaicSize.xyxy;\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},circle:{"circle.frag":"precision lowp float;\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float dist = length(v_offset);\nmediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\nlowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\ngl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","circle.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_circleTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_antialiasingWidth;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_stroke_color = stroke_color * stroke_opacity;\nv_stroke_width = stroke_width;\nv_radius = radius;\nv_blur = max(blur, u_antialiasingWidth / (radius + stroke_width));\nmediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\nv_offset = offset;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos * 0.5, 1.0) + u_displayMat3 * vec3((v_radius + v_stroke_width) * offset + u_circleTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},fill:{"fill.frag":"precision lowp float;\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef PATTERN\nmediump vec2 normalizedTextureCoord = fract(v_tileTextureCoord);\nmediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\nlowp vec4 color = texture2D(u_texture, samplePos);\ngl_FragColor = v_color[3] * color;\n#else\ngl_FragColor = v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","fill.vert":"precision mediump float;\nattribute vec2 a_pos;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump float u_depth;\nuniform mediump vec2 u_fillTranslation;\n#ifdef PATTERN\n#include <util/util.glsl>\nuniform mediump vec2 u_mosaicSize;\nuniform mediump float u_patternFactor;\nvarying mediump vec2 v_tileTextureCoord;\nvarying mediump vec4 v_tlbr;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n#ifdef PATTERN\nfloat patternWidth = nextPOT(tlbr.z - tlbr.x);\nfloat patternHeight = nextPOT(tlbr.w - tlbr.y);\nfloat scaleX = 1.0 / (patternWidth * u_patternFactor);\nfloat scaleY = 1.0 / (patternHeight * u_patternFactor);\nmat3 patterMat = mat3(scaleX, 0.0,    0.0,\n0.0,    -scaleY, 0.0,\n0.0,    0.0,    1.0);\nv_tileTextureCoord = (patterMat * vec3(a_pos, 1.0)).xy;\nv_tlbr             = tlbr / u_mosaicSize.xyxy;\n#endif\nvec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},icon:{"icon.frag":"precision mediump float;\nuniform lowp sampler2D u_texture;\n#ifdef SDF\nuniform lowp vec4 u_color;\nuniform lowp vec4 u_outlineColor;\n#endif\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump flaot v_halo_width;\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\n#include <util/encoding.glsl>\nvec4 mixColors(vec4 color1, vec4 color2) {\nfloat compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\nvec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\nreturn vec4(compositeColor, compositeAlpha);\n}\nvoid main()\n{\n#ifdef SDF\nlowp vec4 fillPixelColor = v_color;\nfloat d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\nconst float softEdgeRatio = 0.248062016;\nfloat size = max(v_size.x, v_size.y);\nfloat dist = d * softEdgeRatio * size;\nfillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\nif (v_halo_width > 0.25) {\nlowp vec4 outlinePixelColor = u_outlineColor;\nconst float outlineLimitRatio = (16.0 / 86.0);\nfloat clampedOutlineSize = softEdgeRatio * min(v_halo_width, outlineLimitRatio * max(v_size.x, v_size.y));\noutlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\ngl_FragColor = v_opacity * mixColors(fillPixelColor, outlinePixelColor);\n}\nelse {\ngl_FragColor = v_opacity * fillPixelColor;\n}\n#else\nlowp vec4 texColor = texture2D(u_texture, v_tex);\ngl_FragColor = v_opacity * texColor;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\n#ifdef SDF\nvarying mediump float v_halo_width;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_iconTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying mediump vec2 v_tex;\nvarying lowp float v_opacity;\nvarying mediump vec2 v_size;\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nv_color = color;\nv_opacity = opacity;\n#ifdef SDF\nv_halo_width = halo_width;\n#endif\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_opacity *= interpolatedOpacity;\nmediump float a_angle         = a_levelInfo[1];\nmediump float a_minLevel      = a_levelInfo[2];\nmediump float a_maxLevel      = a_levelInfo[3];\nmediump vec2 a_tex            = a_texAngleRange.xy;\nmediump float delta_z = 0.0;\nmediump float rotated = mod(a_angle + u_mapRotation, 256.0);\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated));\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_opacity, 0.0);\nvec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\nv_size = abs(offset);\n#ifdef SDF\noffset = (120.0 / 86.0) * offset;\n#endif\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayViewMat3 * vec3(size * offset, 0.0) + u_displayMat3 * vec3(u_iconTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_tex = a_tex.xy / u_mosaicSize;\n}"},line:{"line.frag":"precision lowp float;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying mediump float v_blur;\n#if defined (PATTERN) || defined(SDF)\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\nuniform sampler2D u_texture;\nuniform mediump float u_antialiasing;\n#endif\n#ifdef SDF\n#include <util/encoding.glsl>\n#endif\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nmediump float fragDist = length(v_normal) * v_lineHalfWidth;\nlowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n#ifdef PATTERN\nmediump float relativeTexX = fract(v_accumulatedDistance / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY = 0.5 + v_normal.y * v_lineHalfWidth / (v_patternSize.y * v_widthRatio);\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nlowp vec4 color = texture2D(u_texture, texCoord);\ngl_FragColor = alpha * v_color[3] * color;\n#elif defined(SDF)\nmediump float relativeTexX = fract((v_accumulatedDistance * 0.5) / (v_patternSize.x * v_widthRatio));\nmediump float relativeTexY =  0.5 + 0.25 * v_normal.y;\nmediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\nmediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\nfloat dist = d * (v_lineHalfWidth + u_antialiasing / 2.0);\ngl_FragColor = alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n#else\ngl_FragColor = alpha * v_color;\n#endif\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","line.vert":"precision mediump float;\nattribute vec2 a_pos;\nattribute vec4 a_extrude_offset;\nattribute vec4 a_dir_normal;\nattribute vec2 a_accumulatedDistance;\n#pragma header\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_lineTranslation;\nuniform mediump float u_antialiasing;\nuniform mediump float u_depth;\nvarying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\nconst float scale = 1.0 / 31.0;\nconst mediump float tileCoordRatio = 8.0;\n#if defined (SDF)\nconst mediump float sdfPatternHalfWidth = 15.5;\n#endif\n#if defined (PATTERN) || defined(SDF)\nuniform mediump vec2 u_mosaicSize;\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_patternSize;\nvarying mediump float v_widthRatio;\n#endif\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth;\nvarying mediump float v_blur;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\nv_blur = blur + u_antialiasing;\nv_normal = a_dir_normal.zw * scale;\n#if defined (PATTERN) || defined(SDF)\nv_tlbr          = tlbr / u_mosaicSize.xyxy;\nv_patternSize   = vec2(tlbr.z - tlbr.x, tlbr.y - tlbr.w);\n#if defined (PATTERN)\nv_widthRatio = width / v_patternSize.y;\n#else\nv_widthRatio = width / sdfPatternHalfWidth / 2.0;\n#endif\n#endif\nv_lineHalfWidth = (width + u_antialiasing) * 0.5;\nmediump vec2 dir = a_dir_normal.xy * scale;\nmediump vec2 offset_ = a_extrude_offset.zw * scale * offset;\nmediump vec2 dist = v_lineHalfWidth * scale * a_extrude_offset.xy;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos + offset_ * tileCoordRatio / u_zoomFactor, 1.0) + u_displayViewMat3 * vec3(dist, 0.0) + u_displayMat3 * vec3(u_lineTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n#if defined (PATTERN) || defined(SDF)\nv_accumulatedDistance = a_accumulatedDistance.x * u_zoomFactor / tileCoordRatio + dot(dir, dist + offset_);\n#endif\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\n}"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = abs(v_normal.y);\nlowp float alpha = smoothstep(1.0, 0.0, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform mediump vec2 u_fillTranslation;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\nvarying lowp vec2 v_normal;\nconst float scale = 1.0 / 15.0;\nvoid main()\n{\n#pragma main\nv_color = color * opacity;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_normal = a_xnormal;\nmediump vec2 dist = u_outline_width * scale * a_offset;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + u_displayMat3 * vec3(dist + u_fillTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth, 1.0);\n}"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nvarying lowp vec2 v_tex;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif\nvoid main()\n{\nlowp float dist = texture2D(u_texture, v_tex).a;\nmediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist);\ngl_FragColor = alpha * v_color;\n#ifdef ID\nif (gl_FragColor.a < 1.0 / 255.0) {\ndiscard;\n}\ngl_FragColor = v_id;\n#endif\n}","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_texAngleRange;\nattribute vec4 a_levelInfo;\nattribute float a_opacityInfo;\n#pragma header\nvarying lowp vec4 v_color;\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform mediump vec2 u_textTranslation;\nuniform vec2 u_mosaicSize;\nuniform mediump float u_depth;\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\nuniform lowp float u_keepUpright;\nuniform mediump float u_fadeDuration;\nvarying lowp vec2 v_tex;\nconst float offsetPrecision = 1.0 / 8.0;\nconst mediump float edgePos = 0.75;\nuniform mediump float u_antialiasingWidth;\nvarying mediump float v_edgeDistance;\nvarying mediump float v_edgeWidth;\nuniform lowp float u_halo;\nconst float sdfFontScale = 1.0 / 24.0;\nconst float sdfPixel = 3.0;\nuniform highp float u_time;\nvoid main()\n{\n#pragma main\nif (u_halo > 0.5)\n{\nv_color = halo_color * opacity;\nhalo_width *= sdfPixel;\nhalo_blur *= sdfPixel;\n}\nelse\n{\nv_color = color * opacity;\nhalo_width = 0.0;\nhalo_blur = 0.0;\n}\nfloat modded = mod(a_opacityInfo, 128.0);\nfloat targetOpacity = (a_opacityInfo - modded) / 128.0;\nfloat startOpacity = modded / 127.0;\nfloat interpolatedOpacity = clamp(startOpacity + 2.0 * (targetOpacity - 0.5) * u_time / u_fadeDuration, 0.0, 1.0);\nv_color *= interpolatedOpacity;\nmediump float a_angle       = a_levelInfo[1];\nmediump float a_minLevel    = a_levelInfo[2];\nmediump float a_maxLevel    = a_levelInfo[3];\nmediump vec2 a_tex          = a_texAngleRange.xy;\nmediump float a_visMinAngle    = a_texAngleRange.z;\nmediump float a_visMaxAngle    = a_texAngleRange.w;\nmediump float delta_z = 0.0;\nmediump float angle = mod(a_angle + u_mapRotation, 256.0);\nif (a_visMinAngle < a_visMaxAngle)\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) + (1.0 - step(a_visMinAngle, angle)));\n}\nelse\n{\ndelta_z += (1.0 - step(u_keepUpright, 0.0)) * (step(a_visMaxAngle, angle) * (1.0 - step(a_visMinAngle, angle)));\n}\ndelta_z += 1.0 - step(a_minLevel, u_level);\ndelta_z += step(a_maxLevel, u_level);\ndelta_z += step(v_color[3], 0.0);\nv_tex = a_tex.xy / u_mosaicSize;\n#ifdef ID\nv_id = u_id / 255.0;\n#endif\nv_edgeDistance = edgePos - halo_width / size;\nv_edgeWidth = (u_antialiasingWidth + halo_blur) / size;\nmediump vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + sdfFontScale * u_displayViewMat3 * vec3(offsetPrecision * size * a_vertexOffset, 0.0) + u_displayMat3 * vec3(u_textTranslation, 0.0);\ngl_Position = vec4(pos.xy, u_depth + delta_z, 1.0);\n}"},util:{"encoding.glsl":"const vec4 rgba2float_factors = vec4(\n255.0 / (256.0),\n255.0 / (256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0),\n255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n);\nfloat rgba2float(vec4 rgba) {\nreturn dot(rgba, rgba2float_factors);\n}","util.glsl":"float nextPOT(in float x) {\nreturn pow(2.0, ceil(log2(abs(x))));\n}"}};const a=new(i(78311).B)((function(e){let t=n;return e.split("/").forEach((e=>{t&&(t=t[e])})),t}));function r(e){return a.resolveIncludes(e)}},71200:(e,t,i)=>{i.d(t,{k3:()=>o,s5:()=>r});Math.PI;const n=1/Math.LN2;function a(e,t){return(e%=t)>=0?e:e+t}function r(e){return a(.7111111111111111*e,256)}function o(e){return Math.log(e)*n}},29316:(e,t,i)=>{i.d(t,{Z:()=>n});class n{constructor(){this.name=this.constructor.name||"UnnamedBrush",this.brushEffect=null}prepareState(e,t){}draw(e,t,i){}drawMany(e,t,i){for(const n of t)n.visible&&this.draw(e,n,i)}}},10929:(e,t,i)=>{i.d(t,{J:()=>m});var n=i(19431),a=i(61681),r=i(19710),o=i(18916),l=i(14266),s=i(38716),d=i(8530),c=i(29316),u=i(78951),f=i(91907),_=i(29620);class m extends c.Z{constructor(){super(...arguments),this._color=(0,o.f)(1,0,0,1),this._patternMatrix=(0,r.c)(),this._programOptions={id:!1,pattern:!1}}dispose(){this._vao&&(this._vao.dispose(),this._vao=null)}drawMany(e,t){const{context:i,painter:r,styleLayerUID:o,requestRender:c,allowDelayedRender:u}=e;this._loadWGLResources(e);const _=e.displayLevel,m=e.styleLayer,p=m.backgroundMaterial,v=r.vectorTilesMaterialManager,g=m.getPaintValue("background-color",_),h=m.getPaintValue("background-opacity",_),y=m.getPaintValue("background-pattern",_),T=void 0!==y,x=g[3]*h,w=1|window.devicePixelRatio,I=e.spriteMosaic;let E,M;const S=w>l.a?2:1,P=e.drawPhase===s.jx.HITTEST,C=this._programOptions;C.id=P,C.pattern=T;const R=v.getMaterialProgram(i,p,C);if(u&&(0,a.pC)(c)&&!R.compiled)c();else{if(i.bindVAO(this._vao),i.useProgram(R),T){const e=I.getMosaicItemPosition(y,!0);if((0,a.pC)(e)){const{tl:t,br:n,page:r}=e;E=n[0]-t[0],M=n[1]-t[1];const o=I.getPageSize(r);(0,a.pC)(o)&&(I.bind(i,f.cw.LINEAR,r,l.V4),R.setUniform4f("u_tlbr",t[0],t[1],n[0],n[1]),R.setUniform2fv("u_mosaicSize",o),R.setUniform1i("u_texture",l.V4))}R.setUniform1f("u_opacity",h)}else this._color[0]=x*g[0],this._color[1]=x*g[1],this._color[2]=x*g[2],this._color[3]=x,R.setUniform4fv("u_color",this._color);if(R.setUniform1f("u_depth",m.z||0),P){const e=(0,d.Au)(o+1);R.setUniform4fv("u_id",e)}for(const e of t){if(R.setUniform1f("u_coord_range",e.rangeX),R.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),T){const t=Math.max(2**(Math.round(_)-e.key.level),1),i=S*e.width*t,a=i/(0,n.fp)(E),r=i/(0,n.fp)(M);this._patternMatrix[0]=a,this._patternMatrix[4]=r,R.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix)}i.setStencilFunction(f.wb.EQUAL,0,255),i.drawArrays(f.MX.TRIANGLE_STRIP,0,4)}}}_loadWGLResources(e){if(this._vao)return;const{context:t,styleLayer:i}=e,n=i.backgroundMaterial,a=new Int8Array([0,0,1,0,0,1,1,1]),r=u.f.createVertex(t,f.l1.STATIC_DRAW,a),o=new _.U(t,n.getAttributeLocations(),n.getLayoutInfo(),{geometry:r});this._vao=o}}},92677:(e,t,i)=>{i.d(t,{j:()=>d});var n=i(61681),a=i(93712),r=i(38716),o=i(8530),l=i(29316),s=i(91907);class d extends l.Z{constructor(){super(...arguments),this._programOptions={id:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:l,requiredLevel:d,state:c,drawPhase:u,painter:f,spriteMosaic:_,styleLayerUID:m,requestRender:p,allowDelayedRender:v}=e;if(!t.some((e=>e.layerData.get(m)?.circleIndexCount??!1)))return;const g=e.styleLayer,h=g.circleMaterial,y=f.vectorTilesMaterialManager,T=g.getPaintValue("circle-translate",l),x=g.getPaintValue("circle-translate-anchor",l),w=u===r.jx.HITTEST,I=this._programOptions;I.id=w;const E=y.getMaterialProgram(i,h,I);if(v&&(0,n.pC)(p)&&!E.compiled)return void p();i.useProgram(E),E.setUniformMatrix3fv("u_displayMat3",x===a.fD.VIEWPORT?c.displayMat3:c.displayViewMat3),E.setUniform2fv("u_circleTranslation",T),E.setUniform1f("u_depth",g.z),E.setUniform1f("u_antialiasingWidth",1.2);let M=-1;if(w){const e=(0,o.Au)(m+1);E.setUniform4fv("u_id",e)}for(const e of t){if(!e.layerData.has(m))continue;e.key.level!==M&&(M=e.key.level,h.setDataUniforms(E,l,g,M,_));const t=e.layerData.get(m);if(!t.circleIndexCount)continue;t.prepareForRendering(i);const a=t.circleVertexArrayObject;(0,n.Wi)(a)||(i.bindVAO(a),E.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),d!==e.key.level?i.setStencilFunction(s.wb.EQUAL,e.stencilRef,255):i.setStencilFunction(s.wb.GREATER,255,255),i.drawElements(s.MX.TRIANGLES,t.circleIndexCount,s.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t.circleIndexStart),e.triangleCount+=t.circleIndexCount/3)}}}},28035:(e,t,i)=>{i.d(t,{R:()=>u});var n=i(61681),a=i(93712),r=i(14266),o=i(38716),l=i(8530),s=i(29316),d=i(91907);const c=1/65536;class u extends s.Z{constructor(){super(...arguments),this._fillProgramOptions={id:!1,pattern:!1},this._outlineProgramOptions={id:!1}}dispose(){}drawMany(e,t){const{displayLevel:i,drawPhase:n,renderPass:a,spriteMosaic:r,styleLayerUID:s}=e;let d=!1;for(const e of t)if(e.layerData.has(s)){const t=e.layerData.get(s);if(t.fillIndexCount>0||t.outlineIndexCount>0){d=!0;break}}if(!d)return;const c=e.styleLayer,u=c.getPaintProperty("fill-pattern"),f=void 0!==u,_=f&&u.isDataDriven;let m;if(f&&!_){const e=u.getValue(i);m=r.getMosaicItemPosition(e,!0)}const p=!f&&c.getPaintValue("fill-antialias",i);let v,g=!0,h=1;if(!f){const e=c.getPaintProperty("fill-color"),t=c.getPaintProperty("fill-opacity");if(!e?.isDataDriven&&!t?.isDataDriven){const e=c.getPaintValue("fill-color",i);h=c.getPaintValue("fill-opacity",i)*e[3],h>=1&&(g=!1)}}if(g&&"opaque"===a)return;n===o.jx.HITTEST&&(v=(0,l.Au)(s+1));const y=c.getPaintValue("fill-translate",i),T=c.getPaintValue("fill-translate-anchor",i);(g||"translucent"!==a)&&this._drawFill(e,s,c,t,y,T,f,m,_,v);const x=!c.hasDataDrivenOutlineColor&&c.outlineUsesFillColor&&h<1;p&&"opaque"!==a&&!x&&this._drawOutline(e,s,c,t,y,T,v)}_drawFill(e,t,i,l,s,u,f,_,m,p){if(f&&!m&&(0,n.Wi)(_))return;const{context:v,displayLevel:g,state:h,drawPhase:y,painter:T,pixelRatio:x,spriteMosaic:w,requestRender:I,allowDelayedRender:E}=e,M=i.fillMaterial,S=T.vectorTilesMaterialManager,P=x>r.a?2:1,C=y===o.jx.HITTEST,R=this._fillProgramOptions;R.id=C,R.pattern=f;const b=S.getMaterialProgram(v,M,R);if(E&&(0,n.pC)(I)&&!b.compiled)return void I();if(v.useProgram(b),(0,n.pC)(_)){const{page:e}=_,t=w.getPageSize(e);(0,n.pC)(t)&&(w.bind(v,d.cw.LINEAR,e,r.V4),b.setUniform2fv("u_mosaicSize",t),b.setUniform1i("u_texture",r.V4))}b.setUniformMatrix3fv("u_displayMat3",u===a.fD.VIEWPORT?h.displayMat3:h.displayViewMat3),b.setUniform2fv("u_fillTranslation",s),b.setUniform1f("u_depth",i.z+c),C&&b.setUniform4fv("u_id",p);let D=-1;for(const e of l){if(!e.layerData.has(t))continue;e.key.level!==D&&(D=e.key.level,M.setDataUniforms(b,g,i,D,w));const a=e.layerData.get(t);if(!a.fillIndexCount)continue;a.prepareForRendering(v);const o=a.fillVertexArrayObject;if(!(0,n.Wi)(o)){if(v.bindVAO(o),b.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),v.setStencilFunction(d.wb.EQUAL,e.stencilRef,255),f){const t=Math.max(2**(Math.round(g)-e.key.level),1),i=e.rangeX/(P*e.width*t);b.setUniform1f("u_patternFactor",i)}if(m){const e=a.patternMap;if(!e)continue;for(const[t,i]of e){const e=w.getPageSize(t);(0,n.pC)(e)&&(w.bind(v,d.cw.LINEAR,t,r.V4),b.setUniform2fv("u_mosaicSize",e),b.setUniform1i("u_texture",r.V4),v.drawElements(d.MX.TRIANGLES,i[1],d.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]))}}else v.drawElements(d.MX.TRIANGLES,a.fillIndexCount,d.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.fillIndexStart);e.triangleCount+=a.fillIndexCount/3}}}_drawOutline(e,t,i,r,l,s,u){const{context:f,displayLevel:_,state:m,drawPhase:p,painter:v,pixelRatio:g,spriteMosaic:h,requestRender:y,allowDelayedRender:T}=e,x=i.outlineMaterial,w=v.vectorTilesMaterialManager,I=.75/g,E=p===o.jx.HITTEST,M=this._outlineProgramOptions;M.id=E;const S=w.getMaterialProgram(f,x,M);if(T&&(0,n.pC)(y)&&!S.compiled)return void y();f.useProgram(S),S.setUniformMatrix3fv("u_displayMat3",s===a.fD.VIEWPORT?m.displayMat3:m.displayViewMat3),S.setUniform2fv("u_fillTranslation",l),S.setUniform1f("u_depth",i.z+c),S.setUniform1f("u_outline_width",I),E&&S.setUniform4fv("u_id",u);let P=-1;for(const e of r){if(!e.layerData.has(t))continue;e.key.level!==P&&(P=e.key.level,x.setDataUniforms(S,_,i,P,h));const a=e.layerData.get(t);if(a.prepareForRendering(f),!a.outlineIndexCount)continue;const r=a.outlineVertexArrayObject;(0,n.Wi)(r)||(f.bindVAO(r),S.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),f.setStencilFunction(d.wb.EQUAL,e.stencilRef,255),f.drawElements(d.MX.TRIANGLES,a.outlineIndexCount,d.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.outlineIndexStart),e.triangleCount+=a.outlineIndexCount/3)}}}},87190:(e,t,i)=>{i.d(t,{z:()=>c});var n=i(61681),a=i(93712),r=i(14266),o=i(38716),l=i(8530),s=i(29316),d=i(91907);class c extends s.Z{constructor(){super(...arguments),this._programOptions={id:!1,pattern:!1,sdf:!1}}dispose(){}drawMany(e,t){const{context:i,displayLevel:s,state:c,drawPhase:u,painter:f,pixelRatio:_,spriteMosaic:m,styleLayerUID:p,requestRender:v,allowDelayedRender:g}=e;if(!t.some((e=>e.layerData.get(p)?.lineIndexCount??!1)))return;const h=e.styleLayer,y=h.lineMaterial,T=f.vectorTilesMaterialManager,x=h.getPaintValue("line-translate",s),w=h.getPaintValue("line-translate-anchor",s),I=h.getPaintProperty("line-pattern"),E=void 0!==I,M=E&&I.isDataDriven;let S,P;if(E&&!M){const e=I.getValue(s);S=m.getMosaicItemPosition(e)}let C=!1;if(!E){const e=h.getPaintProperty("line-dasharray");if(P=void 0!==e,C=P&&e.isDataDriven,P&&!C){const t=e.getValue(s),i=h.getDashKey(t,h.getLayoutValue("line-cap",s));S=m.getMosaicItemPosition(i)}}const R=1/_,b=u===o.jx.HITTEST,D=this._programOptions;D.id=b,D.pattern=E,D.sdf=P;const L=T.getMaterialProgram(i,y,D);if(g&&(0,n.pC)(v)&&!L.compiled)return void v();if(i.useProgram(L),L.setUniformMatrix3fv("u_displayViewMat3",c.displayViewMat3),L.setUniformMatrix3fv("u_displayMat3",w===a.fD.VIEWPORT?c.displayMat3:c.displayViewMat3),L.setUniform2fv("u_lineTranslation",x),L.setUniform1f("u_depth",h.z),L.setUniform1f("u_antialiasing",R),b){const e=(0,l.Au)(p+1);L.setUniform4fv("u_id",e)}if(S&&(0,n.pC)(S)){const{page:e}=S,t=m.getPageSize(e);(0,n.pC)(t)&&(m.bind(i,d.cw.LINEAR,e,r.V4),L.setUniform2fv("u_mosaicSize",t),L.setUniform1i("u_texture",r.V4))}let A=-1;for(const e of t){if(!e.layerData.has(p))continue;e.key.level!==A&&(A=e.key.level,y.setDataUniforms(L,s,h,A,m));const t=2**(s-A)/_;L.setUniform1f("u_zoomFactor",t);const a=e.layerData.get(p);if(!a.lineIndexCount)continue;a.prepareForRendering(i);const o=a.lineVertexArrayObject;if(!(0,n.Wi)(o)){if(i.bindVAO(o),L.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),i.setStencilFunction(d.wb.EQUAL,e.stencilRef,255),M||C){const e=a.patternMap;if(!e)continue;for(const[t,a]of e){const e=m.getPageSize(t);(0,n.pC)(e)&&(m.bind(i,d.cw.LINEAR,t,r.V4),L.setUniform2fv("u_mosaicSize",e),L.setUniform1i("u_texture",r.V4),i.drawElements(d.MX.TRIANGLES,a[1],d.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a[0]))}}else i.drawElements(d.MX.TRIANGLES,a.lineIndexCount,d.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*a.lineIndexStart);e.triangleCount+=a.lineIndexCount/3}}}}},96049:(e,t,i)=>{i.d(t,{e:()=>_});var n=i(61681),a=i(55542),r=i(2509),o=i(93712),l=i(14266),s=i(38716),d=i(71200),c=i(8530),u=i(29316),f=i(91907);class _ extends u.Z{constructor(){super(...arguments),this._iconProgramOptions={id:!1,sdf:!1},this._sdfProgramOptions={id:!1},this._spritesTextureSize=(0,a.c)()}dispose(){}drawMany(e,t){const{drawPhase:i,styleLayerUID:n}=e,a=e.styleLayer;let r;i===s.jx.HITTEST&&(r=(0,c.Au)(n+1)),this._drawIcons(e,a,t,r),this._drawText(e,a,t,r)}_drawIcons(e,t,i,a){const{context:c,displayLevel:u,drawPhase:f,painter:_,spriteMosaic:m,state:p,styleLayerUID:v,requestRender:g,allowDelayedRender:h}=e,y=t.iconMaterial,T=_.vectorTilesMaterialManager;let x,w=!1;for(const e of i)if(e.layerData.has(v)&&(x=e.layerData.get(v),x.iconPerPageElementsMap.size>0)){w=!0;break}if(!w)return;const I=t.getPaintValue("icon-translate",u),E=t.getPaintValue("icon-translate-anchor",u);let M=t.getLayoutValue("icon-rotation-alignment",u);M===o.aF.AUTO&&(M=t.getLayoutValue("symbol-placement",u)===o.R.POINT?o.aF.VIEWPORT:o.aF.MAP);const S=M===o.aF.MAP,P=t.getLayoutValue("icon-keep-upright",u)&&S,C=x.isIconSDF,R=f===s.jx.HITTEST,b=this._iconProgramOptions;b.id=R,b.sdf=C;const D=T.getMaterialProgram(c,y,b);if(h&&(0,n.pC)(g)&&!D.compiled)return void g();c.useProgram(D),D.setUniformMatrix3fv("u_displayViewMat3",M===o.aF.MAP?p.displayViewMat3:p.displayMat3),D.setUniformMatrix3fv("u_displayMat3",E===o.fD.VIEWPORT?p.displayMat3:p.displayViewMat3),D.setUniform2fv("u_iconTranslation",I),D.setUniform1f("u_depth",t.z),D.setUniform1f("u_mapRotation",(0,d.s5)(p.rotation)),D.setUniform1f("u_keepUpright",P?1:0),D.setUniform1f("u_level",10*u),D.setUniform1i("u_texture",l.V4),D.setUniform1f("u_fadeDuration",r.nN/1e3),R&&D.setUniform4fv("u_id",a);let L=-1;for(const a of i){if(!a.layerData.has(v))continue;if(a.key.level!==L&&(L=a.key.level,y.setDataUniforms(D,u,t,L,m)),x=a.layerData.get(v),0===x.iconPerPageElementsMap.size)continue;x.prepareForRendering(c),x.updateOpacityInfo();const i=x.iconVertexArrayObject;if(!(0,n.Wi)(i)){c.bindVAO(i),D.setUniformMatrix3fv("u_dvsMat3",a.transforms.dvs),D.setUniform1f("u_time",(performance.now()-x.lastOpacityUpdate)/1e3);for(const[t,i]of x.iconPerPageElementsMap)this._renderIconRange(e,D,i,t,a)}}}_renderIconRange(e,t,i,n,a){const{context:r,spriteMosaic:o}=e;this._spritesTextureSize[0]=o.getWidth(n)/4,this._spritesTextureSize[1]=o.getHeight(n)/4,t.setUniform2fv("u_mosaicSize",this._spritesTextureSize),o.bind(r,f.cw.LINEAR,n,l.V4),r.setStencilTestEnabled(!0),r.setStencilFunction(f.wb.GREATER,255,255),r.setStencilWriteMask(0),r.drawElements(f.MX.TRIANGLES,i[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*i[0]),a.triangleCount+=i[1]/3}_drawText(e,t,i,c){const{context:u,displayLevel:_,drawPhase:m,glyphMosaic:p,painter:v,pixelRatio:g,spriteMosaic:h,state:y,styleLayerUID:T,requestRender:x,allowDelayedRender:w}=e,I=t.textMaterial,E=v.vectorTilesMaterialManager;let M,S=!1;for(const e of i)if(e.layerData.has(T)&&(M=e.layerData.get(T),M.glyphPerPageElementsMap.size>0)){S=!0;break}if(!S)return;const P=t.getPaintProperty("text-opacity");if(P&&!P.isDataDriven&&0===P.getValue(_))return;const C=t.getPaintProperty("text-color"),R=!C||C.isDataDriven||C.getValue(_)[3]>0,b=t.getPaintProperty("text-halo-width"),D=t.getPaintProperty("text-halo-color"),L=(!b||b.isDataDriven||b.getValue(_)>0)&&(!D||D.isDataDriven||D.getValue(_)[3]>0);if(!R&&!L)return;let A=t.getLayoutValue("text-rotation-alignment",_);A===o.aF.AUTO&&(A=t.getLayoutValue("symbol-placement",_)===o.R.POINT?o.aF.VIEWPORT:o.aF.MAP);const U=A===o.aF.MAP,O=t.getLayoutValue("text-keep-upright",_)&&U,N=m===s.jx.HITTEST,F=.8*3/g;this._glyphTextureSize||(this._glyphTextureSize=(0,a.f)(p.width/4,p.height/4));const z=t.getPaintValue("text-translate",_),V=t.getPaintValue("text-translate-anchor",_),k=this._sdfProgramOptions;k.id=N;const H=E.getMaterialProgram(u,I,k);if(w&&(0,n.pC)(x)&&!H.compiled)return void x();u.useProgram(H),H.setUniformMatrix3fv("u_displayViewMat3",A===o.aF.MAP?y.displayViewMat3:y.displayMat3),H.setUniformMatrix3fv("u_displayMat3",V===o.fD.VIEWPORT?y.displayMat3:y.displayViewMat3),H.setUniform2fv("u_textTranslation",z),H.setUniform1f("u_depth",t.z+152587890625e-16),H.setUniform2fv("u_mosaicSize",this._glyphTextureSize),H.setUniform1f("u_mapRotation",(0,d.s5)(y.rotation)),H.setUniform1f("u_keepUpright",O?1:0),H.setUniform1f("u_level",10*_),H.setUniform1i("u_texture",l.CU),H.setUniform1f("u_antialiasingWidth",F),H.setUniform1f("u_fadeDuration",r.nN/1e3),N&&H.setUniform4fv("u_id",c);let W=-1;for(const e of i){if(!e.layerData.has(T))continue;if(e.key.level!==W&&(W=e.key.level,I.setDataUniforms(H,_,t,W,h)),M=e.layerData.get(T),0===M.glyphPerPageElementsMap.size)continue;M.prepareForRendering(u),M.updateOpacityInfo();const i=M.textVertexArrayObject;if((0,n.Wi)(i))continue;u.bindVAO(i),H.setUniformMatrix3fv("u_dvsMat3",e.transforms.dvs),u.setStencilTestEnabled(!0),u.setStencilFunction(f.wb.GREATER,255,255),u.setStencilWriteMask(0);const a=(performance.now()-M.lastOpacityUpdate)/1e3;H.setUniform1f("u_time",a),M.glyphPerPageElementsMap.forEach(((t,i)=>{this._renderGlyphRange(u,t,i,p,H,L,R,e)}))}}_renderGlyphRange(e,t,i,n,a,r,o,s){n.bind(e,f.cw.LINEAR,i,l.CU),r&&(a.setUniform1f("u_halo",1),e.drawElements(f.MX.TRIANGLES,t[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),s.triangleCount+=t[1]/3),o&&(a.setUniform1f("u_halo",0),e.drawElements(f.MX.TRIANGLES,t[1],f.g.UNSIGNED_INT,Uint32Array.BYTES_PER_ELEMENT*t[0]),s.triangleCount+=t[1]/3)}}},38716:(e,t,i)=>{var n,a,r,o,l,s,d;i.d(t,{LW:()=>n,Un:()=>s,X:()=>o,jx:()=>a,mD:()=>d,mf:()=>l,pc:()=>r}),function(e){e[e.FILL=0]="FILL",e[e.LINE=1]="LINE",e[e.MARKER=2]="MARKER",e[e.TEXT=3]="TEXT",e[e.LABEL=4]="LABEL"}(n||(n={})),function(e){e[e.NONE=0]="NONE",e[e.MAP=1]="MAP",e[e.LABEL=2]="LABEL",e[e.LABEL_ALPHA=4]="LABEL_ALPHA",e[e.HITTEST=8]="HITTEST",e[e.HIGHLIGHT=16]="HIGHLIGHT",e[e.CLIP=32]="CLIP",e[e.DEBUG=64]="DEBUG",e[e.NUM_DRAW_PHASES=9]="NUM_DRAW_PHASES"}(a||(a={})),function(e){e[e.SIZE=0]="SIZE",e[e.COLOR=1]="COLOR",e[e.OPACITY=2]="OPACITY",e[e.ROTATION=3]="ROTATION"}(r||(r={})),function(e){e[e.NONE=0]="NONE",e[e.OPACITY=1]="OPACITY",e[e.COLOR=2]="COLOR",e[e.ROTATION=4]="ROTATION",e[e.SIZE_MINMAX_VALUE=8]="SIZE_MINMAX_VALUE",e[e.SIZE_SCALE_STOPS=16]="SIZE_SCALE_STOPS",e[e.SIZE_FIELD_STOPS=32]="SIZE_FIELD_STOPS",e[e.SIZE_UNIT_VALUE=64]="SIZE_UNIT_VALUE"}(o||(o={})),function(e){e[e.MINMAX_TARGETS_OUTLINE=128]="MINMAX_TARGETS_OUTLINE",e[e.SCALE_TARGETS_OUTLINE=256]="SCALE_TARGETS_OUTLINE",e[e.FIELD_TARGETS_OUTLINE=512]="FIELD_TARGETS_OUTLINE",e[e.UNIT_TARGETS_OUTLINE=1024]="UNIT_TARGETS_OUTLINE"}(l||(l={})),function(e){e[e.SPRITE=0]="SPRITE",e[e.GLYPH=1]="GLYPH"}(s||(s={})),function(e){e[e.DEFAULT=0]="DEFAULT",e[e.SIMPLE=1]="SIMPLE",e[e.DOT_DENSITY=2]="DOT_DENSITY",e[e.OUTLINE_FILL=3]="OUTLINE_FILL",e[e.OUTLINE_FILL_SIMPLE=4]="OUTLINE_FILL_SIMPLE",e[e.HEATMAP=5]="HEATMAP",e[e.PIE_CHART=6]="PIE_CHART"}(d||(d={}))},8530:(e,t,i)=>{i.d(t,{Au:()=>a,Jz:()=>o,UJ:()=>r});const n=new Float32Array(1);new Uint32Array(n.buffer);function a(e){return[255&e,(65280&e)>>>8,(16711680&e)>>>16,(4278190080&e)>>>24]}function r(e,t){return 65535&e|t<<16}function o(e,t,i,n){return 255&e|(255&t)<<8|(255&i)<<16|n<<24}},19654:(e,t,i)=>{i.d(t,{A:()=>c});var n=i(36663),a=i(23148),r=i(78668),o=i(76868),l=i(81977),s=(i(7283),i(7753),i(40266)),d=i(64862);const c=e=>{let t=class extends e{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.supportsHeightUnitConversion=!1}postscript(e){super.postscript(e),(0,d.qC)(this.layer)&&this.addResolvingPromise(this._validateHeightModelInfo())}async _validateHeightModelInfo(){const e=new AbortController,t=e.signal;this.handles.add((0,a.kB)((()=>e.abort()))),await(0,o.N1)((()=>this.view.defaultsFromMap?.heightModelInfoReady),t),(0,r.k_)(t);const i=(0,d.Wt)(this.layer,this.view.heightModelInfo,this.supportsHeightUnitConversion);if(i)throw i}canResume(){const e=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return super.canResume()&&(!e||!e.minScale||!e.maxScale||e.minScale>=e.maxScale)}getSuspendInfo(){const e=super.getSuspendInfo(),t=this.layer&&"effectiveScaleRange"in this.layer?this.layer.effectiveScaleRange:null;return t&&t.minScale&&t.maxScale&&t.minScale<t.maxScale&&(e.outsideScaleRange=!0),e}};return(0,n._)([(0,l.Cb)()],t.prototype,"view",void 0),(0,n._)([(0,l.Cb)()],t.prototype,"slicePlaneEnabled",void 0),t=(0,n._)([(0,s.j)("esri.views.3d.layers.LayerView3D")],t),t}},8712:(e,t,i)=>{i.d(t,{r:()=>u});var n=i(36663),a=i(70375),r=i(61681),o=i(76868),l=i(81977),s=(i(7283),i(7753),i(40266)),d=i(57686),c=i(13809);const u=e=>{let t=class extends e{get imageFormatIsOpaque(){return!1}get fullExtent(){return this.layer.fullExtent}get isOpaque(){return this.fullOpacity>=1&&this.imageFormatIsOpaque}get dataLevelRange(){const e=this.tileInfo.lods,t=e[0].scale,i=e[e.length-1].scale;return this.levelRangeFromScaleRange(t,i)}get displayLevelRange(){const e=this.tileInfo.lods,t=this.layer.minScale||e[0].scale,i=this.layer.maxScale||e[e.length-1].scale,n=this.levelRangeFromScaleRange(t,i);return this.layer.maxScale&&n.maxLevel++,n}getTileUrl(e,t,i){return this.layer.getTileUrl(e,t,i)}_addTilingSchemeMatchPromise(){if((0,r.Wi)(this.fullExtent))return this.addResolvingPromise(Promise.reject(new a.Z("tilingscheme:extent-not-defined","This layer doesn't define a fullExtent.")));const e=this._getTileInfoSupportError(this.tileInfo,this.fullExtent);if((0,r.pC)(e))return this.addResolvingPromise(Promise.reject(e));const t=(0,o.N1)((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const e=this.view.basemapTerrain.tilingScheme,t=this._getTileInfoCompatibilityError(this.tileInfo,e);if(t)throw t}));this.addResolvingPromise(t)}_getTileInfoSupportError(e,t){const i=(0,c.er)(e,t,this.view.spatialReference,this.view.state.viewingMode);if(i){const e={layer:this.layer,error:i};let t;switch(i.name){case"tilingscheme:spatial-reference-mismatch":case"tilingscheme:global-unsupported-spatial-reference":case"tilingscheme:local-unsupported-spatial-reference":t=new a.Z("layerview:spatial-reference-incompatible","The spatial reference of this layer does not meet the requirements of the view",e);break;default:t=new a.Z("layerview:tiling-scheme-unsupported","The tiling scheme of this layer is not supported by SceneView",e)}return t}return null}_getTileInfoCompatibilityError(e,t){return(0,r.Wi)(e)||!t.compatibleWith(e)?new a.Z("layerview:tiling-scheme-incompatible","The tiling scheme of this layer is incompatible with the tiling scheme of the surface"):null}levelRangeFromScaleRange(e,t){const i={minLevel:0,maxLevel:1/0},n=this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.tilingScheme;if(!n)return i;const a=n.levels[0],r=e=>{const t=Math.log(a.scale/e)/Math.LN2;return.5-Math.abs(.5-t%1)<1e-9?Math.round(t):Math.ceil(t)};return null!=e&&e>0&&(i.minLevel=Math.max(0,r(e))),null!=t&&t>0&&(i.maxLevel=Math.max(0,r(t))),i}isUpdating(){return!!(this.view&&this.view.basemapTerrain&&this.view.basemapTerrain.updating)}};return(0,n._)([(0,l.Cb)({readOnly:!0})],t.prototype,"imageFormatIsOpaque",null),(0,n._)([(0,l.Cb)({readOnly:!0})],t.prototype,"updating",void 0),(0,n._)([(0,l.Cb)(d.q)],t.prototype,"updatingProgress",void 0),(0,n._)([(0,l.Cb)(d.V)],t.prototype,"updatingProgressValue",void 0),(0,n._)([(0,l.Cb)()],t.prototype,"fullExtent",null),(0,n._)([(0,l.Cb)({readOnly:!0})],t.prototype,"isOpaque",null),(0,n._)([(0,l.Cb)({readOnly:!0})],t.prototype,"dataLevelRange",null),(0,n._)([(0,l.Cb)({readOnly:!0})],t.prototype,"displayLevelRange",null),(0,n._)([(0,l.Cb)()],t.prototype,"layer",void 0),(0,n._)([(0,l.Cb)()],t.prototype,"tileInfo",void 0),t=(0,n._)([(0,s.j)("esri.views.3d.layers.TiledLayerView3D")],t),t}},24747:(e,t,i)=>{i.r(t),i.d(t,{default:()=>H});var n=i(36663),a=i(70375),r=i(61681),o=i(78668),l=i(76868),s=i(81977),d=(i(7283),i(7753),i(40266));class c{constructor(e,t){this._lockedSchemaPixelSize=e,this._isGCS=t}getLevelRowColumn(e){return this._isGCS?[e[0],e[1]>>1,e[2]>>1]:256===this._lockedSchemaPixelSize&&e[0]>0?[e[0]-1,e[1]>>1,e[2]>>1]:e}adjustLevel(e){return this._isGCS?e:256===this._lockedSchemaPixelSize?e>0?e-1:0:e}getShift(e,t){let i=0,n=0;return(256===this._lockedSchemaPixelSize||this._isGCS)&&(e[2]%2&&(i=t),e[1]%2&&(n=t)),[i,n]}getScale(e){if(this._isGCS){if(512===this._lockedSchemaPixelSize)return 4}else if(256===this._lockedSchemaPixelSize&&0===e)return 1;return 2}}var u=i(40366),f=i(19710),_=i(24568),m=i(28249),p=i(31555),v=i(11069),g=i(1563),h=i(61741),y=i(19390),T=i(84099),x=i(93712);var w=i(80361),I=i(87241);class E extends m.m{constructor(e,t,i,n,a){super(e,t,i),this._memCache=n,this._loader=a,this._ongoingTileRequests=new Map,this._ongoingRequestToController=new Map,this._tileInfoView=new w.Z(e.tileInfo,e.fullExtent)}destroy(){super.destroy(),this._ongoingRequestToController.forEach((e=>e.abort())),this._ongoingRequestToController.clear(),this._ongoingTileRequests.clear()}async getVectorTile(e,t,i,n){const a=new I.Z(e,t,i,0);let l=this._memCache.get(a.id);if((0,r.pC)(l))return l.retain(),l;const s=await this._getVectorTileData(a);if((0,o.k_)(n),!this._layer)return null;if(l=this._memCache.get(a.id),(0,r.pC)(l))return l.retain(),l;const d=this._layer.tileInfo.getTileBounds((0,_.Ue)(),a),c=this._tileInfoView.getTileResolution(e);return l=new p.i(a,c,d[0],d[3],512,512,this._styleRepository,this._memCache),(0,r.pC)(s)?(l.setData(s),l.retain(),this._memCache.put(a.id,l,l.memoryUsage*l.referenced,u.an)):l.setData(null),l.neededForCoverage=!0,l.transforms.tileUnitsToPixels=(0,f.f)(1/8,0,0,0,1/8,0,0,0,1),function(e,t){const i=[],n=new y.L(4096,i,(()=>{const e=new v.J;return e.show=!1,e.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),e.parts.push({startTime:0,startOpacity:0,targetOpacity:0,show:!1}),e})),a=new h.g(i,n,((t,i,n)=>new g.f(t,i,n,e.styleRepository,e.key.level,0)),((e,t)=>{(0,T.C$)(e,t,!1)}),(()=>0),(e=>{const i=t.getStyleLayerByUID(e).getLayoutProperty("visibility");return!i||i.getValue()!==x.EE.NONE}));i.push(e),n.add(e),a.setScreenSize(512,512),a.continue(1/0)}(l,this._styleRepository),l}_getVectorTileData(e){const t=e.id;if(this._ongoingTileRequests.has(t))return this._ongoingTileRequests.get(t);const i=new AbortController,n={signal:i.signal},a=this._getParsedVectorTileData(e,n).then((e=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),e))).catch((()=>(this._ongoingTileRequests.delete(t),this._ongoingRequestToController.delete(t),null)));return this._ongoingTileRequests.set(t,a),this._ongoingRequestToController.set(t,i),a}_getParsedVectorTileData(e,t){return this.fetchTileData(e,t).then((i=>this.parseTileData({key:e,data:i},t)))}request(e,t){return this._loader.request(e,"binary",t)}}var M=i(10929),S=i(92677),P=i(28035),C=i(87190),R=i(96049);const b={vtlBackground:M.J,vtlFill:P.R,vtlLine:C.z,vtlCircle:S.j,vtlSymbol:R.e};var D=i(33987),L=i(91907);const A=1e-6;class U{constructor(e,t){this.spriteMosaic=e,this.glyphMosaic=t,this._brushCache=new Map,this._vtlMaterialManager=new D.Z}dispose(){this._brushCache&&(this._brushCache.forEach((e=>e.dispose())),this._brushCache=null),this._vtlMaterialManager=(0,r.M2)(this._vtlMaterialManager),this.spriteMosaic.dispose(),this.glyphMosaic.dispose()}get vectorTilesMaterialManager(){return this._vtlMaterialManager}drawTile(e,t,i){const{context:n}=e,a=i.layers;i.backgroundBucketIds.length>0&&(e.renderPass="background",i.backgroundBucketIds.forEach((n=>this._renderStyleLayer(i.getLayerById(n),e,t,!0)))),n.setBlendingEnabled(!1),n.setDepthTestEnabled(!0),n.setDepthWriteEnabled(!0),n.setDepthFunction(L.wb.LEQUAL),e.renderPass="opaque";for(let i=a.length-1;i>=0;i--)this._renderStyleLayer(a[i],e,t,!1);n.setDepthWriteEnabled(!1),n.setBlendingEnabled(!0),n.setBlendFunctionSeparate(L.zi.ONE,L.zi.ONE_MINUS_SRC_ALPHA,L.zi.ONE,L.zi.ONE_MINUS_SRC_ALPHA),e.renderPass="translucent";for(let i=0;i<a.length;i++)this._renderStyleLayer(a[i],e,t,!1);n.setDepthTestEnabled(!1),n.bindVAO()}_renderStyleLayer(e,t,i,n=!1){if(!(n||e&&i.layerData.has(e.uid)))return;const a=e.getLayoutProperty("visibility");if(a&&a.getValue()===x.EE.NONE)return;const{renderPass:r}=t;let o;switch(e.type){case x.fR.BACKGROUND:if("background"!==r)return;o="vtlBackground";break;case x.fR.FILL:if("opaque"!==r&&"translucent"!==t.renderPass)return;o="vtlFill";break;case x.fR.LINE:if("translucent"!==r)return;o="vtlLine";break;case x.fR.CIRCLE:if("translucent"!==r)return;o="vtlCircle";break;case x.fR.SYMBOL:if("translucent"!==r)return;o="vtlSymbol"}const l=t.displayLevel;void 0!==e.minzoom&&e.minzoom>l+A||void 0!==e.maxzoom&&e.maxzoom<=l-A||(t.styleLayerUID=e.uid,t.styleLayer=e,this._drawWithBrush(t,i,o))}_drawWithBrush(e,t,i){if(!this._brushCache.has(i)){const e=b[i];this._brushCache.set(i,new e)}this._brushCache.get(i).drawMany(e,[t])}}var O=i(63043),N=i(19654),F=i(8712),z=i(13809),V=i(26216);let k=class extends((0,F.r)((0,N.A)(V.Z))){constructor(){super(...arguments),this._tileHandlerController=null,this.type="vector-tile-3d"}initialize(){if((0,r.Wi)(this.layer.fullExtent))return void this.addResolvingPromise(Promise.reject(new a.Z("vectortilelayerview:full-extent-undefined","This layer view's layer does not define a fullExtent.")));const{basemapTerrain:e,spatialReference:t,state:i,viewingMode:n}=this.view,s="local"===n&&!(0,z.jO)(t)||z.Bu.force512VTL,d=this.layer.tileInfo.spatialReference.isGeographic,u=s?this.layer.tileInfo:this.layer.tileInfo.getOrCreateCompatible(256,d?1:2),f=this._getTileInfoSupportError(u,this.layer.fullExtent);if((0,r.pC)(f))return this.addResolvingPromise(Promise.reject(f));const _=(0,l.N1)((()=>this.view?.basemapTerrain?.tilingSchemeLocked)).then((()=>{const t=e.tilingScheme,i=t.pixelSize;let n;if(this.schemaHelper=new c(i,(0,r.pC)(e.spatialReference)&&e.spatialReference.isGeographic),256===i){const e=this.layer.tileInfo.spatialReference.isGeographic;n=this.layer.tileInfo.getOrCreateCompatible(256,e?1:2)}else n=this.view.spatialReference?.isGeographic?this.layer.tileInfo.getOrCreateCompatible(512,.5):this.layer.tileInfo;const a=this._getTileInfoCompatibilityError(n,t);if(a)throw a;this.tileInfo=n}));this._tileHandlerController=new AbortController;const m=this.view.resourceController;this._memCache=m.memoryController.newCache(this.layer.uid,(e=>{e.release()}));const p=new O.Z(this.layer.currentStyleInfo.style),v=e.mapTileRequester;this._tileHandler=new E(this.layer,p,i.contentPixelRatio,this._memCache,v);const g=this._tileHandlerController.signal,h=e=>m.immediate.schedule(e),y=this._tileHandler.start({signal:g,schedule:h}),T=this._tileHandler.spriteMosaic;T.then((e=>{!(0,o.Hc)(g)&&this._tileHandler&&(this.painter=new U(e,this._tileHandler.glyphMosaic))})),y.then((()=>this._tileHandlerController=null)),this.updatingHandles.add((()=>({style:this.layer.currentStyleInfo.style,pixelRatio:this.view.state?.contentPixelRatio})),(({style:e,pixelRatio:t})=>{this._tileHandlerController&&this._tileHandlerController.abort(),this._tileHandlerController=new AbortController,this._memCache.clear();const i=new O.Z(e),n=new E(this.layer,i,t,this._memCache,v),a=n.start({signal:this._tileHandlerController.signal,schedule:h}),r=n.spriteMosaic;a.then((()=>this._tileHandlerController=null)),this.updatingHandles.addPromise(Promise.all([a,r]).then((([,e])=>{const t=this._tileHandler,i=this.painter;this.painter=new U(e,n.glyphMosaic),this._tileHandler=n,this.emit("data-changed"),t.destroy(),i&&i.dispose()})))}));const x=Promise.all([_,y,T]);this.addResolvingPromise(x)}destroy(){this.painter=(0,r.M2)(this.painter),this._tileHandlerController=(0,r.IM)(this._tileHandlerController),(0,r.SC)(this._tileHandler),this._memCache=(0,r.SC)(this._memCache),this._tileHandler=null}get dataLevelRange(){const e=this.tileInfo.lods,t=e[0].scale,i=e[e.length-1].scale,n=this.levelRangeFromScaleRange(t,i);return 1===n.minLevel&&256===this.tileInfo.size[0]&&(n.minLevel=0),n}async fetchTile(e,t,i,n){return this._tileHandler.getVectorTile(e,t,i,n)}};(0,n._)([(0,s.Cb)()],k.prototype,"layer",void 0),(0,n._)([(0,s.Cb)()],k.prototype,"dataLevelRange",null),(0,n._)([(0,s.Cb)()],k.prototype,"updatingProgressValue",void 0),k=(0,n._)([(0,d.j)("esri.views.3d.layers.VectorTileLayerView3D")],k);const H=k},78311:(e,t,i)=>{i.d(t,{B:()=>n});class n{constructor(e){this._readFile=e}resolveIncludes(e){return this._resolve(e)}_resolve(e,t=new Map){if(t.has(e))return t.get(e);const i=this._read(e);if(!i)throw new Error(`cannot find shader file ${e}`);const n=/^[^\S\n]*#include\s+<(\S+)>[^\S\n]?/gm;let a=n.exec(i);const r=[];for(;null!=a;)r.push({path:a[1],start:a.index,length:a[0].length}),a=n.exec(i);let o=0,l="";return r.forEach((e=>{l+=i.slice(o,e.start),l+=t.has(e.path)?"":this._resolve(e.path,t),o=e.start+e.length})),l+=i.slice(o),t.set(e,l),l}_read(e){return this._readFile(e)}}},73353:(e,t,i)=>{function n(e){const{options:t,value:i}=e;return"number"==typeof t[i]}function a(e){let t="";for(const i in e){const a=e[i];if("boolean"==typeof a)a&&(t+=`#define ${i}\n`);else if("number"==typeof a)t+=`#define ${i} ${a.toFixed()}\n`;else if("object"==typeof a)if(n(a)){const{value:e,options:n,namespace:r}=a,o=r?`${r}_`:"";for(const e in n)t+=`#define ${o}${e} ${n[e].toFixed()}\n`;t+=`#define ${i} ${o}${e}\n`}else{const e=a.options;let n=0;for(const i in e)t+=`#define ${e[i]} ${(n++).toFixed()}\n`;t+=`#define ${i} ${e[a.value]}\n`}}return t}i.d(t,{K:()=>a})}}]);