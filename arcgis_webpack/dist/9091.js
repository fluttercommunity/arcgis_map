"use strict";(self.webpackChunkarcgis_webpack01=self.webpackChunkarcgis_webpack01||[]).push([[9091],{19091:(t,e,r)=>{r.r(e),r.d(e,{BufferObject:()=>i.f,FramebufferObject:()=>o.X,Program:()=>a.$,ProgramCache:()=>s.G,Renderbuffer:()=>n.r,ShaderCompiler:()=>h.B,Texture:()=>c.x,VertexArrayObject:()=>l.U,createContextOrErrorHTML:()=>u.sj,createProgram:()=>_.H,glslifyDefineMap:()=>p.K});var i=r(78951),o=r(18567),a=r(69609),s=r(59720),n=r(37165),h=r(78311),c=r(43487),l=r(29620),p=r(73353),_=r(84172),u=r(36172)},59720:(t,e,r)=>{r.d(e,{G:()=>s});var i=r(61681);class o{constructor(){this._outer=new Map}clear(){this._outer.clear()}get empty(){return 0===this._outer.size}get(t,e){return this._outer.get(t)?.get(e)}set(t,e,r){const i=this._outer.get(t);i?i.set(e,r):this._outer.set(t,new Map([[e,r]]))}delete(t,e){const r=this._outer.get(t);r&&(r.delete(e),0===r.size&&this._outer.delete(t))}forEach(t){this._outer.forEach(((e,r)=>t(e,r)))}}var a=r(69609);class s{constructor(t){this._rctx=t,this._store=new o}dispose(){this._store.forEach((t=>t.forEach((t=>t.dispose())))),this._store.clear()}acquire(t,e,r,o){const s=this._store.get(t,e);if((0,i.pC)(s))return s.ref(),s;const n=new a.$(this._rctx,t,e,r,o);return n.ref(),this._store.set(t,e,n),n}get test(){let t=0;return this._store.forEach((e=>e.forEach((e=>t+=e.hasGLName?2:1)))),{cachedWebGLObjects:t}}}},43487:(t,e,r)=>{r.d(e,{x:()=>c}),r(39994);var i=r(19431),o=r(61681),a=r(6174),s=r(36172),n=r(91907),h=r(79193);class c{constructor(t,e,r=null){if(this._context=t,this.type="texture",this._glName=null,this._descriptor=void 0,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,t.instanceCounter.increment(n._g.Texture,this),this._descriptor={target:n.No.TEXTURE_2D,samplingMode:n.cw.LINEAR,wrapMode:n.e8.REPEAT,flipped:!1,hasMipmap:!1,isOpaque:!1,unpackAlignment:4,preMultiplyAlpha:!1,isImmutable:!1,...e},t.type!==s.zO.WEBGL2&&(this._descriptor.isImmutable&&(this._descriptor.isImmutable=!1),_(this._descriptor.target)))throw new Error("3D and array textures are not supported in WebGL1");this._descriptor.target===n.No.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}dispose(){this._context.gl&&this._glName&&(this._context.unbindTexture(this),this._context.gl.deleteTexture(this._glName),this._glName=null,this._context.instanceCounter.decrement(n._g.Texture,this))}release(){this.dispose()}resize(t,e){const r=this._descriptor;if(r.width!==t||r.height!==e){if(this._wasImmutablyAllocated)throw new Error("Immutable textures can't be resized!");r.width=t,r.height=e,this._descriptor.target===n.No.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}_setDataCubeMap(t=null){for(let e=n.No.TEXTURE_CUBE_MAP_POSITIVE_X;e<=n.No.TEXTURE_CUBE_MAP_NEGATIVE_Z;e++)this._setData(t,e)}setData(t){this._setData(t)}_setData(t,e){if(!this._context||!this._context.gl)return;const r=this._context.gl;this._glName||(this._glName=r.createTexture()),void 0===t&&(t=null);const i=this._descriptor;e??(e=i.target);const s=_(e);null===t&&(i.width=i.width||4,i.height=i.height||4,s&&(i.depth=i.depth??1));const d=this._context.bindTexture(this,c.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(c.TEXTURE_UNIT_FOR_UPDATES),c._validateTexture(this._context,i),this._configurePixelStorage();const m=i.pixelFormat;let E=i.internalFormat?i.internalFormat:this._deriveInternalFormat(m,i.dataType);if(p(t)){let o=t.width,n=t.height;const h=1;t instanceof HTMLVideoElement&&(o=t.videoWidth,n=t.videoHeight),i.width&&i.height,s&&i.depth,i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,E,i.hasMipmap,o,n,h),this._texImage(e,0,E,o,n,h,t),(0,a.zu)(r),i.hasMipmap&&this.generateMipmap(),void 0===i.width&&(i.width=o),void 0===i.height&&(i.height=n),s&&void 0===i.depth&&(i.depth=h)}else{const{width:c,height:p,depth:_}=i;if(null!=c&&null!=p||console.error("Width and height must be specified!"),s&&null==_&&console.error("Depth must be specified!"),i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(e,E,i.hasMipmap,c,p,_),r.DEPTH24_STENCIL8&&E===r.DEPTH_STENCIL&&(E=r.DEPTH24_STENCIL8),l(t)){const o=t.levels,a=u(e,c,p,_),s=Math.min(a-1,o.length-1);(0,h.Z)(r)?r.texParameteri(i.target,r.TEXTURE_MAX_LEVEL,s):i.hasMipmap=i.hasMipmap&&a===o.length;const l=E;if(!function(t){return t in n.q_}(l))throw new Error("Attempting to use compressed data with an umcompressed format!");this._forEachMipmapLevel(((t,r,i,a)=>{const s=o[Math.min(t,o.length-1)];this._compressedTexImage(e,t,l,r,i,a,s)}),s)}else(0,o.pC)(t)?(this._texImage(e,0,E,c,p,_,t),(0,a.zu)(r),i.hasMipmap&&this.generateMipmap()):this._forEachMipmapLevel(((t,i,o,s)=>{this._texImage(e,t,E,i,o,s,null),(0,a.zu)(r)}))}c._applySamplingMode(r,this._descriptor),c._applyWrapMode(r,this._descriptor),c._applyAnisotropicFilteringParameters(this._context,this._descriptor),(0,a.zu)(r),this._context.bindTexture(d,c.TEXTURE_UNIT_FOR_UPDATES)}updateData(t,e,r,i,o,a){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const s=this._context.gl,n=this._descriptor,{pixelFormat:h,internalFormat:_,dataType:u,isImmutable:d,target:m}=n;if(d&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");const E=this._context.bindTexture(this,c.TEXTURE_UNIT_FOR_UPDATES);(e<0||r<0||i>n.width||o>n.height||e+i>n.width||r+o>n.height)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),p(a)?s.texSubImage2D(m,t,e,r,h,u,a):l(a)?s.compressedTexSubImage2D(m,t,e,r,i,o,_,a.levels[t]):s.texSubImage2D(m,t,e,r,i,o,h,u,a),this._context.bindTexture(E,c.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,e,r,i,o,a,s,n){n||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");const p=this._context.gl;if(!(0,h.Z)(p))throw new Error("3D textures are not supported in WebGL1");const u=this._descriptor,{pixelFormat:d,dataType:m,isImmutable:E,target:g,internalFormat:T}=u;if(E&&!this._wasImmutablyAllocated)throw new Error("Cannot update immutable texture before allocation!");_(g)||console.warn("Attempting to set 3D texture data on a non-3D texture");const x=this._context.bindTexture(this,c.TEXTURE_UNIT_FOR_UPDATES);if(this._context.setActiveTexture(c.TEXTURE_UNIT_FOR_UPDATES),(e<0||r<0||i<0||o>u.width||a>u.height||s>u.depth||e+o>u.width||r+a>u.height||i+s>u.depth)&&console.error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage(),l(n))n=n.levels[t],p.compressedTexSubImage3D(g,t,e,r,i,o,a,s,T,n);else{const h=n;p.texSubImage3D(g,t,e,r,i,o,a,s,d,m,h)}this._context.bindTexture(x,c.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new Error("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,c._validateTexture(this._context,t)}t.samplingMode===n.cw.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=n.cw.LINEAR_MIPMAP_NEAREST):t.samplingMode===n.cw.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=n.cw.NEAREST_MIPMAP_NEAREST);const e=this._context.bindTexture(this,c.TEXTURE_UNIT_FOR_UPDATES);this._context.setActiveTexture(c.TEXTURE_UNIT_FOR_UPDATES),this._context.gl.generateMipmap(t.target),this._context.bindTexture(e,c.TEXTURE_UNIT_FOR_UPDATES)}setSamplingMode(t){t!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=t,this._samplingModeDirty=!0)}setWrapMode(t){t!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=t,c._validateTexture(this._context,this._descriptor),this._wrapModeDirty=!0)}applyChanges(){const t=this._context.gl,e=this._descriptor;this._samplingModeDirty&&(c._applySamplingMode(t,e),this._samplingModeDirty=!1),this._wrapModeDirty&&(c._applyWrapMode(t,e),this._wrapModeDirty=!1)}_deriveInternalFormat(t,e){if(this._context.type===s.zO.WEBGL1)return t;switch(e){case n.Br.FLOAT:switch(t){case n.VI.RGBA:return n.lP.RGBA32F;case n.VI.RGB:return n.lP.RGB32F;default:throw new Error("Unable to derive format")}case n.Br.UNSIGNED_BYTE:switch(t){case n.VI.RGBA:return n.lP.RGBA8;case n.VI.RGB:return n.lP.RGB8}default:return t}}_configurePixelStorage(){const t=this._context.gl,{unpackAlignment:e,flipped:r,preMultiplyAlpha:i}=this._descriptor;t.pixelStorei(t.UNPACK_ALIGNMENT,e),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,r?1:0),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,i?1:0)}_texStorage(t,e,r,i,o,a){const s=this._context.gl;if(!(0,h.Z)(s))throw new Error("Immutable textures are not supported in WebGL1");if(!function(t){return t in n.lP}(e))throw new Error("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const c=r?u(t,i,o,a):1;_(t)?s.texStorage3D(t,c,e,i,o,a):s.texStorage2D(t,c,e,i,o),this._wasImmutablyAllocated=!0}_texImage(t,e,r,i,a,n,h){const c=this._context.gl;let l=null;const u=this._context.type===s.zO.WEBGL2,d=_(t),{isImmutable:m,pixelFormat:E,dataType:g}=this._descriptor;if(u&&(l=c),u||!p(h))if(m){if((0,o.pC)(h)){const r=h;d?l.texSubImage3D(t,e,0,0,0,i,a,n,E,g,r):c.texSubImage2D(t,e,0,0,i,a,E,g,r)}}else{const s=(0,o.Wg)(h);d?l.texImage3D(t,e,r,i,a,n,0,E,g,s):c.texImage2D(t,e,r,i,a,0,E,g,s)}else c.texImage2D(t,0,r,E,g,h)}_compressedTexImage(t,e,r,i,a,n,h){const c=this._context.gl;let l=null;const p=_(t),u=this._descriptor.isImmutable;if(p){if(this._context.type!==s.zO.WEBGL2)throw new Error("3D textures are not supported in WebGL1");l=c}u?(0,o.pC)(h)&&(p?l.compressedTexSubImage3D(t,e,0,0,0,i,a,n,r,h):c.compressedTexSubImage2D(t,e,0,0,i,a,r,h)):p?l.compressedTexImage3D(t,e,r,i,a,n,0,h):c.compressedTexImage2D(t,e,r,i,a,0,h)}_forEachMipmapLevel(t,e=1/0){let{width:r,height:i,depth:o,hasMipmap:a,target:s}=this._descriptor;const h=s===n.No.TEXTURE_3D;for(let s=0;t(s,r,i,o),a&&(1!==r||1!==i||h&&1!==o)&&!(s>=e);++s)r=Math.max(1,r>>1),i=Math.max(1,i>>1),h&&(o=Math.max(1,o>>1))}static _validateTexture(t,e){(e.width<0||e.height<0||e.depth<0)&&console.error("Negative dimension parameters are not allowed!");const r=(0,h.Z)(t.gl),o=(0,i.wt)(e.width)&&(0,i.wt)(e.height);r||!e.isImmutable&&!_(e.target)||console.error("Immutable and 3D-like textures are not supported in WebGL1!"),r||o||("number"==typeof e.wrapMode?e.wrapMode!==n.e8.CLAMP_TO_EDGE&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):e.wrapMode.s===n.e8.CLAMP_TO_EDGE&&e.wrapMode.t===n.e8.CLAMP_TO_EDGE||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),e.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))}static _applySamplingMode(t,e){let r=e.samplingMode,i=e.samplingMode;r===n.cw.LINEAR_MIPMAP_NEAREST||r===n.cw.LINEAR_MIPMAP_LINEAR?(r=n.cw.LINEAR,e.hasMipmap||(i=n.cw.LINEAR)):r!==n.cw.NEAREST_MIPMAP_NEAREST&&r!==n.cw.NEAREST_MIPMAP_LINEAR||(r=n.cw.NEAREST,e.hasMipmap||(i=n.cw.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,i)}static _applyWrapMode(t,e){"number"==typeof e.wrapMode?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}static _applyAnisotropicFilteringParameters(t,e){const r=t.capabilities.textureFilterAnisotropic;r&&t.gl.texParameterf(e.target,r.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}}function l(t){return(0,o.pC)(t)&&"type"in t&&"compressed"===t.type}function p(t){return(0,o.pC)(t)&&!l(t)&&!function(t){return(0,o.pC)(t)&&"byteLength"in t}(t)}function _(t){return t===n.No.TEXTURE_3D||t===n.No.TEXTURE_2D_ARRAY}function u(t,e,r,i=1){let o=Math.max(e,r);return t===n.No.TEXTURE_3D&&(o=Math.max(o,i)),Math.round(Math.log(o)/Math.LN2)+1}c.TEXTURE_UNIT_FOR_UPDATES=0},79193:(t,e,r)=>{function i(t){return window.WebGL2RenderingContext&&t instanceof window.WebGL2RenderingContext}r.d(e,{Z:()=>i})},6174:(t,e,r)=>{r.d(e,{CG:()=>h,hZ:()=>n,zu:()=>c});var i=r(70375),o=r(39994);const a=r(13802).Z.getLogger("esri/views/webgl"),s=!!(0,o.Z)("enable-feature:webgl-debug");function n(){return s}function h(){return s}function c(t){if(n()){const e=t.getError();if(e){const r=function(t,e){switch(e){case t.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case t.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case t.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case t.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case t.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case t.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}(t,e),o=(new Error).stack;a.error(new i.Z("webgl-error","WebGL error occured",{message:r,stack:o}))}}}},73353:(t,e,r)=>{function i(t){const{options:e,value:r}=t;return"number"==typeof e[r]}function o(t){let e="";for(const r in t){const o=t[r];if("boolean"==typeof o)o&&(e+=`#define ${r}\n`);else if("number"==typeof o)e+=`#define ${r} ${o.toFixed()}\n`;else if("object"==typeof o)if(i(o)){const{value:t,options:i,namespace:a}=o,s=a?`${a}_`:"";for(const t in i)e+=`#define ${s}${t} ${i[t].toFixed()}\n`;e+=`#define ${r} ${s}${t}\n`}else{const t=o.options;let i=0;for(const r in t)e+=`#define ${t[r]} ${(i++).toFixed()}\n`;e+=`#define ${r} ${t[o.value]}\n`}}return e}r.d(e,{K:()=>o})}}]);